import Foundation
import Combine
import FirebaseFirestore
import FirebaseAuth

class StoreService: ObservableObject {
    @Published var orders: [CakeOrder] = []
    @Published var menuItems: [CakeItem] = []
    @Published var currentUser: UserProfile?
    
    private var db = Firestore.firestore()
    internal var auth = Auth.auth()
    
    private var ordersListener: ListenerRegistration?
    private var menuListener: ListenerRegistration?
    private var userListener: ListenerRegistration?
    
    var isUserLoggedIn: Bool {
        auth.currentUser != nil
    }
    
    init() {
        // We handle fetching in signIn() which is triggered by onAppear in ContentView
    }
    
    // MARK: - Auth
    func signIn() {
        print("DEBUG: Starting auth listener...")
        
        // Clear existing listeners if any (e.g. if re-signing in)
        ordersListener?.remove()
        menuListener?.remove()
        userListener?.remove()
        
        // If user is already logged in, fetch immediately
        if let user = auth.currentUser {
            print("DEBUG: User already logged in: \(user.uid)")
            self.fetchUserProfile(uid: user.uid)
            self.fetchOrders()
            self.fetchMenu()
        }
        
        auth.addStateDidChangeListener { [weak self] _, user in
            if let user = user {
                print("DEBUG: Auth State Changed -> Logged In: \(user.uid)")
                self?.fetchUserProfile(uid: user.uid)
                self?.fetchOrders()
                self?.fetchMenu()
            } else {
                print("DEBUG: Auth State Changed -> Logged Out")
                self?.ordersListener?.remove()
                self?.menuListener?.remove()
                self?.userListener?.remove()
                self?.currentUser = nil
                self?.orders = []
                self?.menuItems = []
            }
        }
    }
    
    func emailSignIn(email: String, password: String, completion: @escaping (Error?) -> Void) {
        auth.signIn(withEmail: email, password: password) { _, error in
            completion(error)
        }
    }
    
    func emailSignUp(email: String, password: String, fullName: String, completion: @escaping (Error?) -> Void) {
        auth.createUser(withEmail: email, password: password) { result, error in
            if let uid = result?.user.uid {
                let profile = UserProfile(id: uid, fullName: fullName, email: email, createdAt: ISO8601DateFormatter().string(from: Date()), role: "user")
                try? self.db.collection("users").document(uid).setData(from: profile)
            }
            completion(error)
        }
    }
    
    func signOut() {
        ordersListener?.remove()
        menuListener?.remove()
        userListener?.remove()
        try? auth.signOut()
    }
    
    private func fetchUserProfile(uid: String) {
        userListener?.remove()
        userListener = db.collection("users").document(uid).addSnapshotListener { snapshot, _ in
            guard let snapshot = snapshot else { return }
            self.currentUser = try? snapshot.data(as: UserProfile.self)
        }
    }
    
    // MARK: - Orders
    func fetchOrders() {
        guard let uid = auth.currentUser?.uid else { return }
        
        ordersListener?.remove()
        print("DEBUG: Starting orders listener for \(uid)")
        ordersListener = db.collection("users").document(uid).collection("orders")
            .order(by: "pickupDate")
            .order(by: "pickupTime")
            .addSnapshotListener { [weak self] querySnapshot, error in
                guard let self = self else { return }
                guard let documents = querySnapshot?.documents else {
                    print("DEBUG: Error fetching orders: \(error?.localizedDescription ?? "Unknown error")")
                    return
                }
                
                print("DEBUG: Real-time update: \(documents.count) orders synced.")
                DispatchQueue.main.async {
                    self.objectWillChange.send()
                    self.orders = documents.compactMap { try? $0.data(as: CakeOrder.self) }
                }
            }
    }
    
    func addOrder(_ order: CakeOrder) {
        guard let uid = auth.currentUser?.uid else { return }
        print("DEBUG: Adding order...")
        do {
            // Optimistic Update: Append locally immediately
            // Note: The real ID is generated by Firestore, so we might have a temporary mismatch until sync,
            // but for UI responsiveness this helps. The listener will correct it shortly.
            self.orders.append(order)
            
            _ = try db.collection("users").document(uid).collection("orders").addDocument(from: order)
        } catch {
            print("Error adding order: \(error.localizedDescription)")
            // Revert on error if needed, but listener will usually fix sync
            self.fetchOrders() 
        }
    }
    
    func updateOrderStatus(orderId: String, status: String) {
        guard let uid = auth.currentUser?.uid else { return }
        print("DEBUG: Updating status to \(status) for \(orderId)")
        
        // Optimistic Update
        if let index = self.orders.firstIndex(where: { $0.id == orderId }) {
            DispatchQueue.main.async {
                self.orders[index].status = status
            }
        }
        
        db.collection("users").document(uid).collection("orders").document(orderId).updateData(["status": status])
    }
    
    func updateOrder(_ order: CakeOrder) {
        guard let uid = auth.currentUser?.uid, let orderId = order.id else { return }
        print("DEBUG: Updating order \(orderId)")
        
        // Optimistic Update
        if let index = self.orders.firstIndex(where: { $0.id == orderId }) {
            DispatchQueue.main.async {
                self.orders[index] = order
            }
        }
        
        do {
            try db.collection("users").document(uid).collection("orders").document(orderId).setData(from: order)
        } catch {
            print("DEBUG: Error updating order: \(error.localizedDescription)")
        }
    }
    
    func deleteOrder(orderId: String) {
        guard let uid = auth.currentUser?.uid else { return }
        print("DEBUG: Deleting order \(orderId)")
        
        // Optimistic Update
        DispatchQueue.main.async {
            self.orders.removeAll { $0.id == orderId }
        }
        
        db.collection("users").document(uid).collection("orders").document(orderId).delete()
    }
    
    // MARK: - Menu
    // MARK: - Menu
    func fetchMenu() {
        guard let uid = auth.currentUser?.uid else { return }
        
        menuListener?.remove()
        print("DEBUG: Starting menu listener for \(uid)")
        menuListener = db.collection("users").document(uid).collection("menu").addSnapshotListener { [weak self] querySnapshot, _ in
            guard let self = self else { return }
            guard let documents = querySnapshot?.documents else { return }
            print("DEBUG: Real-time update: \(documents.count) menu items synced.")
            DispatchQueue.main.async {
                self.objectWillChange.send()
                self.menuItems = documents.compactMap { try? $0.data(as: CakeItem.self) }
            }
        }
    }
    
    func addMenuItem(_ item: CakeItem) {
        guard let uid = auth.currentUser?.uid else { return }
        print("DEBUG: Adding menu item locally...")
        
        // Optimistic Update
        self.menuItems.append(item)
        
        do {
            _ = try db.collection("users").document(uid).collection("menu").addDocument(from: item)
        } catch {
            print("Error adding menu item: \(error.localizedDescription)")
            self.fetchMenu()
        }
    }
    
    func deleteMenuItem(itemId: String) {
        guard let uid = auth.currentUser?.uid else { return }
        print("DEBUG: Deleting menu item \(itemId)")
        
        // Optimistic Update
        DispatchQueue.main.async {
            self.menuItems.removeAll { $0.id == itemId }
        }
        
        db.collection("users").document(uid).collection("menu").document(itemId).delete()
    }
    
    func updateMenuItem(_ item: CakeItem) {
        guard let uid = auth.currentUser?.uid, let itemId = item.id else { return }
        print("DEBUG: Updating menu item \(itemId)")
        
        // Optimistic Update
        if let index = self.menuItems.firstIndex(where: { $0.id == itemId }) {
            DispatchQueue.main.async {
                self.menuItems[index] = item
            }
        }
        
        do {
            try db.collection("users").document(uid).collection("menu").document(itemId).setData(from: item)
        } catch {
            print("Error updating menu item: \(error.localizedDescription)")
            self.fetchMenu()
        }
    }
}
